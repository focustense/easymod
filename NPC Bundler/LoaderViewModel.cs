using Serilog;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;

namespace NPC_Bundler
{
    public class LoaderViewModel<TKey> : INotifyPropertyChanged
        where TKey : struct
    {
        public event Action Loaded;
        public event PropertyChangedEventHandler PropertyChanged;

        public bool CanLoad { get; private set; }
        public bool IsLoading { get; private set; } = true;
        public bool IsLogVisible { get; private set; }
        public bool IsPluginListVisible { get; private set; }
        public bool IsSpinnerVisible { get; private set; }
        public IReadOnlyList<string> LoadedMasterNames { get; private set; }
        public IReadOnlyList<string> LoadedPluginNames { get; private set; }
        public LogViewModel Log { get; private init; }
        public IModPluginMapFactory ModPluginMapFactory => editor.ModPluginMapFactory;
        public IReadOnlyList<INpc<TKey>> Npcs { get; private set; }
        public IReadOnlyList<PluginSetting> Plugins { get; private set; }
        public string Status { get; private set; }

        private readonly IGameDataEditor<TKey> editor;
        private readonly ILogger logger;

        public LoaderViewModel(IGameDataEditor<TKey> editor, LogViewModel logViewModel, ILogger logger)
        {
            this.editor = editor;
            Log = logViewModel;
            this.logger = logger;

            Status = "Starting up...";
            IsSpinnerVisible = true;
            CanLoad = false;

            // TODO: Disable loading of the Merged NPC plugin generated by this tool
            Plugins = editor.GetAvailablePlugins()
                .Select((x, i) => new PluginSetting(x.Item1, i + 1, x.Item2))
                .ToList()
                .AsReadOnly();
            Status = "Confirm plugin selection and load order.";
            IsSpinnerVisible = false;
            IsPluginListVisible = true;
            CanLoad = true;
        }

        public async void ConfirmPlugins()
        {
            CanLoad = false;
            Status = "Loading selected plugins...";
            IsSpinnerVisible = true;
            IsPluginListVisible = false;
            IsLogVisible = true;

            var loadOrder = Plugins.Where(x => x.ShouldLoad).Select(x => x.FileName);
            await editor.Load(loadOrder).ConfigureAwait(true);

            LoadedPluginNames = editor.GetLoadedPlugins().ToList().AsReadOnly();
            LoadedMasterNames = LoadedPluginNames
                .Where(pluginName => editor.IsMaster(pluginName))
                .ToList()
                .AsReadOnly();
            Status = "Done loading plugins. Building NPC index...";
            var loadedNpcs = await Task.Run(GetNpcs).ConfigureAwait(true);
            Npcs = new List<INpc<TKey>>(loadedNpcs);
            logger.Information("All NPCs loaded.");

            Status = "All done.";
            IsSpinnerVisible = false;
            IsLoading = false;
            Loaded?.Invoke();
        }

        private IEnumerable<INpc<TKey>> GetNpcs()
        {
            var npcs = new Dictionary<TKey, IMutableNpc<TKey>>();
            foreach (var pluginName in LoadedPluginNames)
            {
                logger.Information($"Reading NPC records from {pluginName}...");
                editor.ReadNpcRecords(pluginName, npcs);
            }

            var loadOrderIndices = npcs.Values
                .Select(x => x.BasePluginName)
                .Distinct()
                .Select(pluginName => new
                {
                    PluginName = pluginName,
                    LoadOrderIndex = editor.GetLoadOrderIndex(pluginName)
                })
                .ToDictionary(x => x.PluginName, x => x.LoadOrderIndex);
            return npcs.Values
                .OrderBy(x => loadOrderIndices[x.BasePluginName])
                .ThenBy(x => Convert.ToInt32(x.LocalFormIdHex, 16));
        }
    }

    public class PluginSetting : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        public string FileName { get; init; }
        public int Index { get; init; }
        public bool ShouldLoad { get; set; }

        public PluginSetting(string fileName, int index, bool defaultEnabled)
        {
            FileName = fileName;
            Index = index;
            ShouldLoad = defaultEnabled;
        }
    }

    class NpcInfo<TKey> : IMutableNpc<TKey>
        where TKey : struct
    {
        public string BasePluginName { get; set; }
        public string EditorId { get; set; }
        public TKey Key { get; set; }
        public bool IsFemale { get; set; }
        public string LocalFormIdHex { get; set; }
        public string Name { get; set; }
        public List<NpcOverride<TKey>> Overrides { get; set; } = new List<NpcOverride<TKey>>();

        IReadOnlyList<NpcOverride<TKey>> INpc<TKey>.Overrides => Overrides.AsReadOnly();

        public void AddOverride(NpcOverride<TKey> overrideInfo)
        {
            Overrides.Add(overrideInfo);
        }
    }
}
